// Package models contains the types for schema 'public'.
package models

// Code generated by xo. DO NOT EDIT.

// TopicNamesForPage represents a row from '[custom topic_names_for_page]'.
type TopicNamesForPage struct {
	PageID                  int    // page_id
	TopicID                 int    // topic_id
	TopicDisplayName        string // topic_display_name
	TopicName               string // topic_name
	TopicDisplayNameSortKey string // topic_display_name_sort_key
	TopicNameSortKey        string // topic_name_sort_key
}

// TopicNamesForPagesByPage_id runs a custom query, returning results as TopicNamesForPage.
func TopicNamesForPagesByPage_id(db XODB, page_id int) ([]*TopicNamesForPage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT DISTINCT ` +
		`oo.location_id AS page_id, ` +
		`hb.id AS topic_id, ` +
		`hb.display_name AS topic_display_name, ` +
		`hh.name AS topic_name, ` +
		` ` +
		`CASE WHEN LEFT( hb.display_name, 1 ) = '"' ` +
		`THEN LOWER( SUBSTR( hb.display_name, 2 ) ) ` +
		`ELSE LOWER( hb.display_name ) ` +
		`END AS topic_display_name_sort_key, ` +
		` ` +
		`CASE WHEN LEFT( hh.name, 1 ) = '"' ` +
		`THEN LOWER( SUBSTR( hh.name, 2 ) ) ` +
		`ELSE LOWER( hh.name ) ` +
		`END AS topic_name_sort_key ` +
		` ` +
		`FROM occurrence_occurrence oo INNER JOIN hit_basket hb ON oo.basket_id = hb.id ` +
		`INNER JOIN hit_hit hh ON hh.basket_id = hb.id ` +
		` ` +
		`WHERE oo.location_id = $1 ` +
		` ` +
		`ORDER BY page_id, topic_display_name_sort_key, topic_name_sort_key`

	// run query
	XOLog(sqlstr, page_id)
	q, err := db.Query(sqlstr, page_id)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*TopicNamesForPage{}
	for q.Next() {
		tnfp := TopicNamesForPage{}

		// scan
		err = q.Scan(&tnfp.PageID, &tnfp.TopicID, &tnfp.TopicDisplayName, &tnfp.TopicName, &tnfp.TopicDisplayNameSortKey, &tnfp.TopicNameSortKey)
		if err != nil {
			return nil, err
		}

		res = append(res, &tnfp)
	}

	return res, nil
}
