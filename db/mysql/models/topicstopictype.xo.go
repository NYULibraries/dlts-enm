// Package models contains the types for schema 'enm'.
package models

// GENERATED BY XO. DO NOT EDIT.

// TopicsTopicType represents a row from 'enm.topics_topic_type'.
type TopicsTopicType struct {
	TopicID     int `json:"topic_id"`      // topic_id
	TopicTypeID int `json:"topic_type_id"` // topic_type_id
}

// TopicType returns the TopicType associated with the TopicsTopicType's TopicTypeID (topic_type_id).
//
// Generated from foreign key 'fk__topics_topic_type__topic_type'.
func (ttt *TopicsTopicType) TopicType(db XODB) (*TopicType, error) {
	return TopicTypeByTctID(db, ttt.TopicTypeID)
}

// Topic returns the Topic associated with the TopicsTopicType's TopicID (topic_id).
//
// Generated from foreign key 'fk__topics_topic_type__topics'.
func (ttt *TopicsTopicType) Topic(db XODB) (*Topic, error) {
	return TopicByTctID(db, ttt.TopicID)
}

// TopicsTopicTypesByTopicID retrieves a row from 'enm.topics_topic_type' as a TopicsTopicType.
//
// Generated from index 'topic_id'.
func TopicsTopicTypesByTopicID(db XODB, topicID int) ([]*TopicsTopicType, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`topic_id, topic_type_id ` +
		`FROM enm.topics_topic_type ` +
		`WHERE topic_id = ?`

	// run query
	XOLog(sqlstr, topicID)
	q, err := db.Query(sqlstr, topicID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*TopicsTopicType{}
	for q.Next() {
		ttt := TopicsTopicType{}

		// scan
		err = q.Scan(&ttt.TopicID, &ttt.TopicTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &ttt)
	}

	return res, nil
}

// TopicsTopicTypesByTopicTypeID retrieves a row from 'enm.topics_topic_type' as a TopicsTopicType.
//
// Generated from index 'topic_type_id'.
func TopicsTopicTypesByTopicTypeID(db XODB, topicTypeID int) ([]*TopicsTopicType, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`topic_id, topic_type_id ` +
		`FROM enm.topics_topic_type ` +
		`WHERE topic_type_id = ?`

	// run query
	XOLog(sqlstr, topicTypeID)
	q, err := db.Query(sqlstr, topicTypeID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*TopicsTopicType{}
	for q.Next() {
		ttt := TopicsTopicType{}

		// scan
		err = q.Scan(&ttt.TopicID, &ttt.TopicTypeID)
		if err != nil {
			return nil, err
		}

		res = append(res, &ttt)
	}

	return res, nil
}
